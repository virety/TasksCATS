// Условие
// Турнир по олимпийской системе, состоящий из N раундов, проводятся между 2^N участниками по следующей схеме: сначала составляется последовательность из расставленных в произвольном порядке игроков. В первом раунде первый в последовательности участник соревнуется со вторым, третий с четвёртым, и т.д. Проигравшие выбывают из турнира, и на втором раунде победитель первой пары играет с победителем второй, победитель третьей с победителем четвёртой, и т.д. Наконец, после N-го раунда остаётся ровно один участник, который становится победителем турнира.
// История таких турниров наглядно изображается с помощью специальной диаграммы, которая называется турнирной сеткой.
// Назовём упорядоченной такую первоначальную последовательность участников, что в каждом матче сетки победителем оказывается первый участник. Например, первоначальная последовательность в приведённой справа сетке не соответствует этому условию — чтобы это исправить, нужно расположить участников в порядке: Life, MarineKing, TaeJa, Leenock, Mvp, Symbol, Rain, Hero.
// Требуется по результатам всех проведённых в турнире матчей получить упорядоченную первоначальную расстановку участников.
// Рекомендуется рассмотреть частичные решения
// N≤10;
// Формат входного файла
// Входной файла содержит целое число N, за которым следуют 2^N−1 пар чисел WiLi, означающих, что участник с номером Wi победил участника с номером Li. Участники пронумерованы от 1 до 2^N.
// Формат выходного файла
// Выходной файл должен содержать 2^N целых чисел — номера участников, перечисленные в соответствии с упорядоченной первоначальной расстановкой.
// Ограничения
// 1≤N≤20
// Примеры тестов
// №	Входной файл (input.txt)	Выходной файл (output.txt)
// 1	3                           7 8 6 5 3 4 1 2 
//     1 2  3 1  7 3
//     7 6  6 5  7 8  3 4
#include<algorithm>
#include<iostream>
#include<vector>
#include<fstream>
using namespace std;
using pii = pair<int, int>;

int main()
{
    ifstream fin("input.txt");
    ofstream fout("output.txt");
    int n;
    fin >> n;
    vector<pii> matches;
    vector<int> deeps(1<<n);
    vector < vector < int>> losed(1<<n);
    
    for (int i = 0; i < (1<<n) - 1; i++) {
        int a, b;
        fin >> a >> b;
        a--;
        b--;
        matches.push_back({a, b});
        deeps[a]++;
        losed[a].push_back(b);
    }
    
    for (int i = 0; i < (1<<n); i++) {
        sort(losed[i].begin(), losed[i].end(), [&](int a, int b) {return deeps[a] < deeps[b];});
    }
    vector<pii> anses((1<<n) - 1);
    vector<int> nowdeep((1<<n) - 1);
    nowdeep[0] = n - 1;
    anses[0].first = max_element(deeps.begin(), deeps.end()) - deeps.begin(); // 2
    for (int i = 0; i < (1<<(n - 1)) - 1; i++) {
        nowdeep[i * 2 + 1] = nowdeep[i] - 1;
        nowdeep[i * 2 + 2] = nowdeep[i] - 1;
    }
    for (int v = 0; v < (1<<n) - 1; v++) {
        anses[v].second = losed[anses[v].first][nowdeep[v]];
        if (v * 2 + 1 < (int)anses.size()) {
            anses[v * 2 + 1].first = anses[v].first;
            anses[v * 2 + 2].first = anses[v].second;
        }
    }
    for (int i = (1<<(n - 1)) - 1; i < (1<<n) - 1; i++) {
        fout << anses[i].first + 1 << ' ' << anses[i].second + 1 << ' ';
    }
}