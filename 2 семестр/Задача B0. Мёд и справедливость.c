// Условие
// Две пчелы собирают пыльцу с N цветков, расположенных в ряд. Цветок номер i содержит ai микрограмм пыльцы.
// Пчёлы договорились, что первая пчела будет собирать пыльцу с цветков на участке от L до M включительно, а вторая  — от M+1 до R включительно (L≤M<R). Чтобы ни одной из пчёл не было обидно, сумма запасов пыльцы на первом и втором участках пчёл должны совпадать.
// Требуется написать программу, которая найдёт подходящие участки с наибольшим возможным количеством пыльцы.
// Формат входных данных
// Входные данные содержат целое число N, за которым следует N чисел ai.
// Формат выходных данных
// Выходные данные должны содержать целые числа LMR — границы участков. Если оптимальных решений несколько, выведите решение с наименьшим значением L. Если решения не существует, выведите единственное число −1.
// Ограничения
// 2≤N≤10000
// 1≤ai≤10^5
// Примеры тестов
// №	Стандартный вход	Стандартный выход
// 1	3                   1 2 3
//     1 1 2
// 2	2                   -1
//     2 5
#include <stdio.h>

int main() {
    int N, m, r;
    scanf("%d", &N);
    int arr[N];
    for (int i = 0; i < N; i++) {
        scanf("%d", &arr[i]);
    }

    int mid_sum = -1;
    int l = -1;

    for (int i = 0; i < N; i++) {
        int left_sum = 0;
        int right_sum = arr[i];
        int mid_pos = i + 1;

        for (int j = i; j < N; j++) {
            right_sum -= arr[j];
            left_sum += arr[j];

            while (mid_pos < N && right_sum < left_sum) {
                right_sum += arr[mid_pos];
                mid_pos++;
            }

            if (left_sum == right_sum && mid_sum < left_sum) {
                mid_sum = left_sum;
                l = i;
                m = j;
                r = mid_pos;
            }
        }
    }

    if (l == -1) printf("-1");
    else printf("%d %d %d", l + 1, m + 1, r);

    return 0;
}